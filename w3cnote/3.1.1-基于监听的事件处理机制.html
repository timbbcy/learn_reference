<div class="article-intro">
<h2>本节引言：</h2>
<blockquote><p>第二章我们学习的是Android的UI控件，我们可以利用这些控件构成一个精美的界面，但是仅仅是界面而已；下一步就要开始学习逻辑与业务实现了，本章节讲解的是Android的事件处理机制！何为事件处理机制？举个
简单的例子，比如点击一个按钮，我们向服务器发送登陆请求！当然，Android中的事件处理机制不止这一种，
比如屏幕发生选择，我们点击了屏幕上某个区域...简单点说，事件处理机制就是我们和UI发生交互时，我们在背后添加一些小动作而已！本节我们来介绍使用的最频繁的一种：基于监听的事件处理机制！</p></blockquote>
<hr/>
<h2>1.基于监听的时间处理机制模型:</h2>
<p><strong>流程模型图：</strong></p>
<p><img alt="" src="http://www.runoob.com/wp-content/uploads/2015/07/4109430.jpg"/></p>
<p><strong>文字表述：</strong></p>
<blockquote><p>事件监听机制中由<strong>事件源</strong>，<strong>事件</strong>，<strong>事件监听器</strong>三类对象组成
处理流程如下:
<strong>Step 1:</strong>为某个事件源(组件)设置一个监听器,用于监听用户操作
<strong>Step 2:</strong>用户的操作,触发了事件源的监听器
<strong>Step 3:</strong>生成了对应的事件对象
<strong>Step 4:</strong>将这个事件源对象作为参数传给事件监听器
<strong>step 5:</strong>事件监听器对事件对象进行判断,执行对应的事件处理器(对应事件的处理方法)</p></blockquote>
<p><strong>归纳：</strong></p>
<blockquote><p>事件监听机制是一种委派式的事件处理机制,事件源(组件)事件处理委托给事件监听器
当事件源发生指定事件时,就通知指定事件监听器,执行相应的操作</p></blockquote>
<hr/>
<h2>2.五种不同的使用形式：</h2>
<p>我们以下面这个：
<strong>简单的按钮点击,提示Toast信息的程序；</strong>使用五种不同的形式来实现！</p>
<p><strong>效果图：</strong></p>
<p><img alt="" src="http://www.runoob.com/wp-content/uploads/2015/07/61197180.jpg"/></p>
<hr/>
<h3>1）直接用匿名内部类</h3>
<blockquote><p>平时最常用的一种:直接setXxxListener后,重写里面的方法即可;
通常是临时使用一次,复用性不高！</p></blockquote>
<p>实现代码如下：<strong>MainAcivity.java:</strong></p>
<pre>
package com.jay.example.innerlisten;    
    
import android.os.Bundle;    
import android.view.View;    
import android.view.View.OnClickListener;    
import android.widget.Button;    
import android.widget.Toast;    
import android.app.Activity;    
    
    
public class MainActivity extends Activity {    
    private Button btnshow;    
        
    @Override    
    protected void onCreate(Bundle savedInstanceState) {    
        super.onCreate(savedInstanceState);    
        setContentView(R.layout.activity_main);    
        btnshow = (Button) findViewById(R.id.btnshow);    
        btnshow.setOnClickListener(new OnClickListener() {    
            //重写点击事件的处理方法onClick()    
            @Override    
            public void onClick(View v) {    
                //显示Toast信息    
                Toast.makeText(getApplicationContext(), "你点击了按钮", Toast.LENGTH_SHORT).show();    
            }    
        });    
    }        
} 
</pre>
<hr/>
<h3>2）使用内部类</h3>
<blockquote><p>和上面的匿名内部类不同哦！
使用优点:可以在该类中进行复用,可直接访问外部类的所有界面组件！</p></blockquote>
<p>实现代码如下：<strong>MainAcivity.java:</strong></p>
<pre>
package com.jay.example.innerlisten;    
    
import android.os.Bundle;    
import android.view.View;    
import android.view.View.OnClickListener;    
import android.widget.Button;    
import android.widget.Toast;    
import android.app.Activity;    
    
    
public class MainActivity extends Activity {    
    private Button btnshow;    
    @Override    
    protected void onCreate(Bundle savedInstanceState) {    
        super.onCreate(savedInstanceState);    
        setContentView(R.layout.activity_main);    
        btnshow = (Button) findViewById(R.id.btnshow);    
        //直接new一个内部类对象作为参数    
        btnshow.setOnClickListener(new BtnClickListener());    
    }     
    //定义一个内部类,实现View.OnClickListener接口,并重写onClick()方法    
    class BtnClickListener implements View.OnClickListener    
    {    
        @Override    
        public void onClick(View v) {    
            Toast.makeText(getApplicationContext(), "按钮被点击了", Toast.LENGTH_SHORT).show();   
        }    
    }    
} 
</pre>
<hr/>
<h3>3）使用外部类：</h3>
<blockquote><p>就是另外创建一个处理事件的Java文件,这种形式用的比较少！因为外部类不能直接访问用户界面
类中的组件,要通过构造方法将组件传入使用;这样导致的结果就是代码不够简洁！</p></blockquote>
<p>ps:为了演示传参,这里用TextView代替Toast提示！</p>
<p><img alt="" src="http://www.runoob.com/wp-content/uploads/2015/07/72939526.jpg"/></p>
<p>实现代码如下：<strong>MyClick.java:</strong>
</p>
<pre>
package com.jay.example.innerlisten;    
    
import android.view.View;    
import android.view.View.OnClickListener;    
import android.widget.TextView;    
    
public class MyClick implements OnClickListener {    
    private TextView textshow;    
    //把文本框作为参数传入    
    public MyClick(TextView txt)    
    {    
        textshow = txt;    
    }    
    @Override    
    public void onClick(View v) {    
        //点击后设置文本框显示的文字    
        textshow.setText("点击了按钮!");    
    }    
}
</pre>
<p><strong>MainActivity.java</strong></p>
<pre>
package com.jay.example.innerlisten;    
import android.os.Bundle;    
import android.widget.Button;    
import android.widget.TextView;    
import android.app.Activity;    
    
    
public class MainActivity extends Activity {    
    private Button btnshow;    
    private TextView txtshow;    
    @Override    
    protected void onCreate(Bundle savedInstanceState) {    
        super.onCreate(savedInstanceState);    
        setContentView(R.layout.activity_main);    
        btnshow = (Button) findViewById(R.id.btnshow);    
        txtshow = (TextView) findViewById(R.id.textshow);    
        //直接new一个外部类，并把TextView作为参数传入    
        btnshow.setOnClickListener(new MyClick(txtshow));    
    }         
} 
</pre>
<hr/>
<h3>4）直接使用Activity作为事件监听器</h3>
<blockquote><p>只需要让Activity类实现XxxListener事件监听接口,在Activity中定义重写对应的事件处理器方法
eg:Actitity实现了OnClickListener接口,重写了onClick(view)方法在为某些组建添加该事件监听对象
时,直接setXxx.Listener(this)即可</p></blockquote>
<p>实现代码如下：<strong>MainAcivity.java:</strong></p>
<pre>
package com.jay.example.innerlisten;    
import android.os.Bundle;    
import android.view.View;    
import android.view.View.OnClickListener;    
import android.widget.Button;    
import android.widget.Toast;    
import android.app.Activity;    
    
//让Activity方法实现OnClickListener接口    
public class MainActivity extends Activity implements OnClickListener{    
    private Button btnshow;    
    @Override    
    protected void onCreate(Bundle savedInstanceState) {    
        super.onCreate(savedInstanceState);    
        setContentView(R.layout.activity_main);    
            
        btnshow = (Button) findViewById(R.id.btnshow);    
        //直接写个this    
        btnshow.setOnClickListener(this);    
    }    
    //重写接口中的抽象方法    
    @Override    
    public void onClick(View v) {    
        Toast.makeText(getApplicationContext(), "点击了按钮", Toast.LENGTH_SHORT).show();         
    }         
}   
</pre>
<hr/>
<h3>5）直接绑定到标签:</h3>
<blockquote><p>就是直接在xml布局文件中对应得Activity中定义一个事件处理方法
eg:public void myClick(View source)   source对应事件源(组件)
接着布局文件中对应要触发事件的组建,设置一个属性:onclick = "myclick"即可</p></blockquote>
<p>实现代码如下：<strong>MainAcivity.java:</strong></p>
<pre>
package com.jay.example.caller;    
    
import android.app.Activity;    
import android.os.Bundle;    
import android.view.View;    
import android.widget.Toast;    
    
public class MainActivity extends Activity {    
    @Override    
    protected void onCreate(Bundle savedInstanceState) {    
        super.onCreate(savedInstanceState);    
        setContentView(R.layout.activity_main);     
    }    
    //自定义一个方法,传入一个view组件作为参数    
    public void myclick(View source)    
    {    
        Toast.makeText(getApplicationContext(), "按钮被点击了", Toast.LENGTH_SHORT).show();    
    }    
} 
</pre>
<p><strong>main.xml布局文件:</strong></p>
<pre>
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"    
    xmlns:tools="http://schemas.android.com/tools"    
    android:id="@+id/LinearLayout1"    
    android:layout_width="match_parent"    
    android:layout_height="match_parent"    
    android:orientation="vertical" &gt;    
    &lt;Button     
        android:layout_width="wrap_content"    
        android:layout_height="wrap_content"    
        android:text="按钮"    
        android:onClick="myclick"/&gt;    
 &lt;/LinearLayout&gt; 
 </pre>
<hr/>
<h2>本节小结</h2>
<blockquote><p>本节给大家介绍了Android中的事件处理机制，例子中的是onClickListener点击事件，当然除了这个以外还有其他的事件，比如onItemClickListener，凡是需要通过setXxxListener这些，基本上都是基于事件监听的！
另外这五种方式用的比较多的是：1，2，3，5几种，看具体情况而定~</p></blockquote> </div>